package main

import (
    "fmt"
    "github.com/gorilla/websocket"
    "log"
    "net"
    "net/url"
    "os"
    "os/signal"
    "strconv"
    "sync"
    "sync/atomic"
    "time"
)

var (
    // 存储已处理的消息ID
    processedMessages = make(map[uint64]bool)
    // 使用mutex锁来同步对map的访问
    mutex               = &sync.Mutex{}
    socketMutex         = &sync.Mutex{}
    liveConnectionCount = int32(0)
    //测试出效果最佳的应该是128?1024 也能用  似乎是50个conn限制
    connectionLimit = 48
)

var fastboyURL = url.URL{Scheme: "ws", Host: "15.204.102.22:18888", Path: "/FASTERPLEASE"}
var fastBoyConn *websocket.Conn
var fastBoyConnected = false

func main() {
    var err error
    fastBoyConn, _, err = websocket.DefaultDialer.Dial(fastboyURL.String(), nil)
    if err != nil {
        fmt.Println("dial fastboy:", err)
    }
    fastBoyConnected = true
    go keepFastBoyConnection()
    defer fastBoyConn.Close()

    fmt.Println("Starting...")
    interrupt := make(chan os.Signal, 1)
    signal.Notify(interrupt, os.Interrupt)
    var urls []string
    for i := 0; i < connectionLimit; i++ {
        urls = append(urls, "wss://arb1.arbitrum.io/feed")
    }
    var wg sync.WaitGroup
    for index, url := range urls {
        wg.Add(1)
        go func(url string, index int) {
            defer wg.Done()
            conn, _, err := websocket.DefaultDialer.Dial(url, nil)
            if err != nil {
                fmt.Println("Error connecting to WebSocket:", err)
                if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                    fmt.Println("Dial got disconnect: ", liveConnectionCount)
                }
                if opError, ok := err.(*net.OpError); ok {
                    if opError.Err.Error() == "read: connection reset by peer" {
                        // 这里处理 "connection reset by peer"
                        fmt.Println("Dial got disconnect: ", liveConnectionCount)
                    }
                }
                time.Sleep(60 * time.Second)
                reconnect(index)
                return
            } else {
                atomic.AddInt32(&liveConnectionCount, 1)
            }
            messageLoop(conn, index)
        }(url, index)
    }
    wg.Wait()
}

func reconnect(connIndex int) {
    go func(index int) {
        conn, _, err := websocket.DefaultDialer.Dial("wss://arb1.arbitrum.io/feed", nil)
        if err != nil {
            log.Println("Error connecting to WebSocket:", err)
            if websocket.IsCloseError(err, websocket.CloseNormalClosure, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                fmt.Println("Dial got disconnect: ", liveConnectionCount)
            }
            if opError, ok := err.(*net.OpError); ok {
                if opError.Err.Error() == "read: connection reset by peer" {
                    // 这里处理 "connection reset by peer"
                    fmt.Println("Dial got disconnect: ", liveConnectionCount)
                }
            }
            time.Sleep(180 * time.Second)
            reconnect(index)
            return
        } else {
            atomic.AddInt32(&liveConnectionCount, 1)
        }
        messageLoop(conn, index)
    }(connIndex)
}

func messageLoop(conn *websocket.Conn, connIndex int) {
    defer conn.Close()
    for {
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            //log.Println("Error reading message:", err)
            atomic.AddInt32(&liveConnectionCount, -1)
            fmt.Println("Reading got disconnect: ", liveConnectionCount)
            time.Sleep(60 * time.Second)
            reconnect(connIndex)
            return
        }
        go func(messageType int, message []byte, connIndex int) {
            seqStr := string(message[43:52])
            seqNumber, _ := strconv.Atoi(seqStr)
            processMessage(message, messageType, uint64(seqNumber), connIndex)
        }(messageType, message, connIndex)
    }
}

func processMessage(originMessage []byte, originType int, seqNumber uint64, connIndex int) {
    mutex.Lock()
    if _, exists := processedMessages[seqNumber]; exists {
        mutex.Unlock()
        return
    }
    processedMessages[seqNumber] = true
    mutex.Unlock()
    if fastBoyConnected && fastBoyConn != nil {
        var err error
        socketMutex.Lock()
        err = fastBoyConn.WriteMessage(originType, originMessage)
        socketMutex.Unlock()
        if err != nil {
            fastBoyConnected = false
            fastBoyConn.Close()
        }
    }
    go deleteMapAfterDelay(seqNumber)
}

func deleteMapAfterDelay(seqNumber uint64) {
    time.Sleep(10 * time.Second)
    mutex.Lock()
    delete(processedMessages, seqNumber)
    mutex.Unlock()
}

func keepFastBoyConnection() {
    var err error
    for {
        if fastBoyConnected == false {
            fastBoyConn, _, err = websocket.DefaultDialer.Dial(fastboyURL.String(), nil)
            if err != nil {
                fmt.Println("dial fastboy:", err)
            } else {
                fastBoyConnected = true
            }
        }
        time.Sleep(18 * time.Second)
    }
}
